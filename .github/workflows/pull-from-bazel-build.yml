name: Pull Fresh Upstream Documentation

on:
  workflow_call:
    inputs:
      bazelCommitHash:
        description: 'Specific Bazel commit hash to checkout (optional)'
        required: false
        type: string
        default: ''
      bazelPullRequestNumber:
        description: 'Bazel PR number (optional, used to fetch PR refs)'
        required: false
        type: string
        default: ''
      is_internal_pr:
        description: 'Whether this is an internal PR (not from a fork)'
        required: false
        type: boolean
        default: true
      bazelBaseCommitHash:
        description: 'Base Bazel commit hash for change detection (optional)'
        required: false
        type: string
        default: ''
      target_branch:
        description: 'Branch to commit docs updates to (optional)'
        required: false
        type: string
        default: ''
      detect_upstream_docs_changes:
        description: 'Skip the conversion pipeline when upstream docs or reference-doc inputs are unchanged'
        required: false
        type: boolean
        default: false

jobs:
  pull-fresh-upstream:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    
    steps:
      - uses: actions/create-github-app-token@v2
        id: generate-token
        if: ${{ inputs.is_internal_pr }}
        with:
          app-id: ${{ secrets.GH_APP_ID }}
          private-key: ${{ secrets.GH_APP_PRIVATE_KEY }}
          owner: ${{ github.repository_owner }}

      - name: Checkout repository (internal PR)
        if: ${{ inputs.is_internal_pr }}
        uses: actions/checkout@v6
        with:
          submodules: false
          token: ${{ steps.generate-token.outputs.token }}

      - name: Checkout repository (fork)
        if: ${{ !inputs.is_internal_pr }}
        uses: actions/checkout@v6
        with:
          submodules: false
          # No token is provided, so the action will use the default GITHUB_TOKEN
          # with fork-safe, read-only permissions.

      - name: Checkout submodules
        run: git submodule update --init -- upstream

      - name: Checkout commit of Bazel Build submodule
        if: ${{ inputs.bazelCommitHash != '' }}
        working-directory: upstream
        env:
          BAZEL_COMMIT_HASH: ${{ inputs.bazelCommitHash }}
          BAZEL_PR_NUMBER: ${{ inputs.bazelPullRequestNumber }}
        run: |
          set -euo pipefail
          if ! git cat-file -e "${BAZEL_COMMIT_HASH}" 2>/dev/null; then
            if [[ -n "${BAZEL_PR_NUMBER}" ]]; then
              git fetch --no-tags origin "pull/${BAZEL_PR_NUMBER}/head"
            else
              git fetch --no-tags origin "${BAZEL_COMMIT_HASH}"
            fi
          fi
          git checkout "${BAZEL_COMMIT_HASH}"

      - name: Get changed files in upstream
        id: changed-files
        if: ${{ inputs.detect_upstream_docs_changes }}
        uses: tj-actions/changed-files@v47.0.1
        with:
          path: upstream
          base_sha: ${{ inputs.bazelBaseCommitHash }}
          sha: ${{ inputs.bazelCommitHash }}
          files: |
            docs/**
            src/main/java/com/google/devtools/build/lib/**
            src/main/java/com/google/devtools/build/docgen/**
            src/main/starlark/docgen/**
            tools/build_defs/repo/**
            site/command-line-reference-prefix.html
            site/command-line-reference-suffix.html
            site/BUILD
            site/BUILD.bazel

      - name: Determine if pipeline should run
        id: docs-changes
        run: |
          if [[ "${{ inputs.detect_upstream_docs_changes }}" != "true" ]]; then
            echo "should_run=true" >> "$GITHUB_OUTPUT"
          elif [[ "${{ steps.changed-files.outputs.any_changed }}" == "true" ]]; then
            echo "should_run=true" >> "$GITHUB_OUTPUT"
          else
            echo "should_run=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Ensure target branch exists for previews
        if: ${{ inputs.is_internal_pr && inputs.target_branch != '' && steps.docs-changes.outputs.should_run == 'true' }}
        env:
          TARGET_BRANCH: ${{ inputs.target_branch }}
        run: |
          set -euo pipefail
          if git ls-remote --exit-code --heads origin "${TARGET_BRANCH}" >/dev/null; then
            echo "Preview branch ${TARGET_BRANCH} already exists."
            exit 0
          fi
          git push origin "HEAD:${TARGET_BRANCH}"

      - name: Setup Bazel
        if: ${{ steps.docs-changes.outputs.should_run == 'true' }}
        uses: bazel-contrib/setup-bazel@0.18.0
        with:
          bazelisk-cache: true
          repository-cache: true
       
      - name: Build reference documentation (if not a fork)
        if: ${{ inputs.is_internal_pr && steps.docs-changes.outputs.should_run == 'true' }}
        working-directory: upstream
        run: >
          bazel build
          --config=docs
          --build_metadata=ROLE=DOCS
          --remote_header=x-buildbuddy-api-key=${{ secrets.BUILDBUDDY_ORG_API_KEY }}
          --bes_results_url=https://app.buildbuddy.io/invocation/
          --bes_backend=grpcs://remote.buildbuddy.io
          --remote_cache=grpcs://remote.buildbuddy.io
          --remote_timeout=10m
          //src/main/java/com/google/devtools/build/lib:gen_reference_docs
      
      - name: Upload reference docs artifact
        if: ${{ steps.docs-changes.outputs.should_run == 'true' && github.ref != 'refs/heads/main' }}
        uses: actions/upload-artifact@v7
        with:
          name: reference-docs
          path: upstream/bazel-bin/src/main/java/com/google/devtools/build/lib/reference-docs.zip
          retention-days: 7

      - name: Sync pre-converted MDX docs from upstream
        if: ${{ steps.docs-changes.outputs.should_run == 'true' }}
        run: |
          # Copy all MDX files from the upstream docs directory to the root
          rsync -av --include='*/' --include='*.mdx' --include='*.md' --include='*.png' --include='*.jpg' --include='*.svg' --exclude='*' upstream/docs/ .
          
      - name: Unzip reference documentation
        if: ${{ inputs.is_internal_pr && steps.docs-changes.outputs.should_run == 'true' }}
        run: |
          mkdir -p reference-docs-temp
          unzip -o upstream/bazel-bin/src/main/java/com/google/devtools/build/lib/reference-docs.zip -d reference-docs-temp
          # Sync unzipped reference docs to the root
          rsync -av --include='*/' --include='*.mdx' --include='*.md' --include='*.png' --include='*.jpg' --include='*.svg' --exclude='*' reference-docs-temp/ .
          rm -rf reference-docs-temp

      - name: Create versioned navigation
        if: ${{ steps.docs-changes.outputs.should_run == 'true' }}
        run: ./docs.json.update.sh

      - name: Configure Git
        if: ${{ inputs.is_internal_pr && steps.docs-changes.outputs.should_run == 'true' }}
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Commit and push changes
        if: ${{ inputs.is_internal_pr && steps.docs-changes.outputs.should_run == 'true' }}
        env:
          BRANCH_OVERRIDE: ${{ inputs.target_branch }}
          DEFAULT_BRANCH: ${{ github.event.repository.default_branch }}
        run: |
          set -euo pipefail

          BRANCH="${BRANCH_OVERRIDE:-${GITHUB_HEAD_REF:-${GITHUB_REF_NAME}}}"
          DEFAULT_BRANCH="${DEFAULT_BRANCH:-main}"

          # Ensure local branch points at origin/BRANCH and is checked out
          if git ls-remote --exit-code --heads origin "$BRANCH" >/dev/null; then
            git fetch origin "$BRANCH"
            git switch -C "$BRANCH" "origin/$BRANCH"
            git branch --set-upstream-to="origin/$BRANCH" "$BRANCH"

            # Rebase onto latest remote before creating a new commit
            git pull
          else
            git fetch origin "$DEFAULT_BRANCH"
            git switch -C "$BRANCH" "origin/$DEFAULT_BRANCH"
            git branch --set-upstream-to="origin/$DEFAULT_BRANCH" "$BRANCH"
          fi
          
          # Clean up any modified content in submodules (keep pointer changes)
          cd upstream
          git reset --hard
          git clean -fd
          cd ..
          
          if [[ -n "$(git status --porcelain)" ]]; then
            echo "Changes detected, committing and pushing..."
            git add -A
            git commit -m $'chore: update documentation from upstream Bazel repo [skip ci]\n\nSynchronized pre-converted MDX files from upstream Bazel repository.'
          
            # Push back to the same branch
            git push origin "HEAD:$BRANCH"
            echo "Changes committed and pushed successfully"
          else
            echo "No changes detected, skipping commit"
          fi
