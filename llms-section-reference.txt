<SYSTEM>This is the Bazel 'Reference' documentation subset. Use it when you only need this portion of the corpus.</SYSTEM>

# Reference
- Docs snapshot: HEAD
- Generated: 2025-11-12 17:06:48 UTC

## Build encyclopedia

### Bazel BUILD Encyclopedia of Functions
- URL: https://bazel.build/reference/be/overview
- Source: reference/be/overview.mdx

## Concepts and terminology

- [Common definitions](/reference/be/common-definitions)  - [Bourne shell tokenization](/reference/be/common-definitions#sh-tokenization)
  - [Label expansion](/reference/be/common-definitions#label-expansion)
  - [Typical attributes for most rules](/reference/be/common-definitions#typical-attributes)
  - [Common attributes for all rules](/reference/be/common-definitions#common-attributes)
  - [Common attributes for tests](/reference/be/common-definitions#common-attributes-tests)
  - [Common attributes for binaries](/reference/be/common-definitions#common-attributes-binaries)
  - [Configurable attributes](/reference/be/common-definitions#configurable-attributes)
  - [Implicit output targets](/reference/be/common-definitions#implicit-outputs)
- ["Make" variables](/reference/be/make-variables)  - [Use](/reference/be/make-variables#use)

## Functions

- [package](/reference/be/functions.html#package)
- [package\_group](/reference/be/functions.html#package_group)
- [exports\_files](/reference/be/functions.html#exports_files)
- [glob](/reference/be/functions.html#glob)
- [select](/reference/be/functions.html#select)
- [workspace](/rules/lib/globals/workspace#workspace)

## Rules

Native rules ship with the Bazel binary and do not require a `load` statement.
Native rules are available globally in BUILD files. In .bzl files, you can find them in
the `native` module.

For non-native Starlark rules that ship separately from Bazel, see the list of
[recommended rules](/rules/rules#recommended-rules).

### Language-specific native rules

LanguageFlagsBinary rulesLibrary rulesTest rulesOther rulesC / C++[cc\_binary](c-cpp.html#cc_binary)

[cc\_import](c-cpp.html#cc_import)

[cc\_library](c-cpp.html#cc_library)

[cc\_shared\_library](c-cpp.html#cc_shared_library)

[cc\_static\_library](c-cpp.html#cc_static_library)

[cc\_test](c-cpp.html#cc_test)

[cc\_toolchain](c-cpp.html#cc_toolchain)

[fdo\_prefetch\_hints](c-cpp.html#fdo_prefetch_hints)

[fdo\_profile](c-cpp.html#fdo_profile)

[memprof\_profile](c-cpp.html#memprof_profile)

[propeller\_optimize](c-cpp.html#propeller_optimize)

Java[java\_binary](java.html#java_binary)

[java\_import](java.html#java_import)

[java\_library](java.html#java_library)

[java\_test](java.html#java_test)

[java\_package\_configuration](java.html#java_package_configuration)

[java\_plugin](java.html#java_plugin)

[java\_runtime](java.html#java_runtime)

[java\_single\_jar](java.html#java_single_jar)

[java\_toolchain](java.html#java_toolchain)

Objective-C[objc\_import](objective-c.html#objc_import)

[objc\_library](objective-c.html#objc_library)

Protocol Buffer[cc\_proto\_library](protocol-buffer.html#cc_proto_library)

[java\_lite\_proto\_library](protocol-buffer.html#java_lite_proto_library)

[java\_proto\_library](protocol-buffer.html#java_proto_library)

[proto\_library](protocol-buffer.html#proto_library)

[py\_proto\_library](protocol-buffer.html#py_proto_library)

[proto\_lang\_toolchain](protocol-buffer.html#proto_lang_toolchain)

[proto\_toolchain](protocol-buffer.html#proto_toolchain)

Python[py\_binary](python.html#py_binary)

[py\_library](python.html#py_library)

[py\_test](python.html#py_test)

[py\_runtime](python.html#py_runtime)

Shell[sh\_binary](shell.html#sh_binary)

[sh\_library](shell.html#sh_library)

[sh\_test](shell.html#sh_test)

### Language-agnostic native rules

FamilyRulesExtra Actions

- [action\_listener](extra-actions.html#action_listener)
- [extra\_action](extra-actions.html#extra_action)

General

- [alias](general.html#alias)
- [config\_setting](general.html#config_setting)
- [filegroup](general.html#filegroup)
- [genquery](general.html#genquery)
- [genrule](general.html#genrule)
- [starlark\_doc\_extract](general.html#starlark_doc_extract)
- [test\_suite](general.html#test_suite)

Platforms and Toolchains

- [constraint\_setting](platforms-and-toolchains.html#constraint_setting)
- [constraint\_value](platforms-and-toolchains.html#constraint_value)
- [platform](platforms-and-toolchains.html#platform)
- [toolchain](platforms-and-toolchains.html#toolchain)
- [toolchain\_type](platforms-and-toolchains.html#toolchain_type)

### Common definitions
- URL: https://bazel.build/reference/be/common-definitions
- Source: reference/be/common-definitions.mdx

This section defines various terms and concepts that are common to
many functions or build rules.

## Contents

- [Bourne shell tokenization](#sh-tokenization)
- [Label Expansion](#label-expansion)
- [Typical attributes defined by most build rules](#typical-attributes)
- [Attributes common to all build rules](#common-attributes)
- [Attributes common to all test rules (\*\_test)](#common-attributes-tests)
- [Attributes common to all binary rules (\*\_binary)](#common-attributes-binaries)
- [Configurable attributes](#configurable-attributes)
- [Implicit output targets](#implicit-outputs)

## Bourne shell tokenization

Certain string attributes of some rules are split into multiple
words according to the tokenization rules of the Bourne shell:
unquoted spaces delimit separate words, and single- and
double-quotes characters and backslashes are used to prevent
tokenization.

Those attributes that are subject to this tokenization are
explicitly indicated as such in their definitions in this document.

Attributes subject to "Make" variable expansion and Bourne shell
tokenization are typically used for passing arbitrary options to
compilers and other tools. Examples of such attributes are
`cc_library.copts` and `java_library.javacopts`.
Together these substitutions allow a
single string variable to expand into a configuration-specific list
of option words.

## Label expansion

Some string attributes of a very few rules are subject to label
expansion: if those strings contain a valid label as a
substring, such as `//mypkg:target`, and that label is a
declared prerequisite of the current rule, it is expanded into the
pathname of the file represented by the
[target](https://bazel.build/reference/glossary#target) `//mypkg:target`.

Example attributes include `genrule.cmd` and
`cc_binary.linkopts`. The details may vary significantly in
each case, over such issues as: whether relative labels are
expanded; how labels that expand to multiple files are
treated, etc. Consult the rule attribute documentation for
specifics.

## Typical attributes defined by most build rules

This section describes attributes that are defined by many build rules,
but not all.

AttributeDescription`data`

List of [labels](/concepts/labels); default is `[]`

Files needed by this rule at runtime. May list file or rule targets. Generally
allows any target.

The default outputs and runfiles of targets in the `data` attribute
should appear in the `*.runfiles` area of any executable which is
output by or has a runtime dependency on this target. This may include data
files or binaries used when this target's
[`srcs`](#typical.srcs) are executed. See the
[data dependencies](/concepts/dependencies#data-dependencies)
section for more information about how to depend on and use data files.

New rules should define a `data` attribute if they process
inputs which might use other inputs at runtime. Rules' implementation functions
must also [populate the target's\
runfiles](https://bazel.build/rules/rules#runfiles) from the outputs and runfiles of any `data` attribute,
as well as runfiles from any dependency attribute which provides either
source code or runtime dependencies.

`deps`

List of [labels](/concepts/labels); default is `[]`

Dependencies for this target. Generally should only list rule targets. (Though
some rules permit files to be listed directly in `deps`, this
should be avoided when possible.)

Language-specific rules generally limit the listed targets to those with
specific [providers](https://bazel.build/extending/rules#providers).

The precise semantics of what it means for a target to depend on another using
`deps` are specific to the kind of rule, and the rule-specific
documentation goes into more detail. For rules which process source code,
`deps` generally specifies code dependencies used by the code in
[`srcs`](#typical.srcs).

Most often, a `deps` dependency is used to allow one module to use
symbols defined in another module written in the same programming language and
separately compiled. Cross-language dependencies are also permitted in many
cases: For example, a `java_library` target may depend on C++ code
in a `cc_library` target, by listing the latter in the
`deps` attribute. See the definition of
[dependencies](/concepts/build-ref#deps)
for more information.

`licenses`

List of strings; [nonconfigurable](#configurable-attributes);
default is `["none"]`

A list of license-type strings to be used for this particular target.

This is part of a deprecated licensing API that Bazel no longer uses. Don't
use this.

`srcs`

List of [labels](/concepts/labels); default is `[]`

Files processed or included by this rule. Generally lists files directly, but
may list rule targets (like `filegroup` or `genrule`) to
include their default outputs.

Language-specific rules often require that the listed files have particular
file extensions.

## Attributes common to all build rules

This section describes attributes that are implicitly added to all build
rules.

AttributeDescription`aspect_hints`

List of [labels](/concepts/labels); default is `[]`

A list of arbitrary labels which is exposed to [aspects](/extending/aspects) (in
particular - aspects invoked by this rule's reverse dependencies), but isn't exposed to this rule's
own implementation. Consult documentation for language-specific rule sets for details about what
effect a particular aspect hint would have.

You could think of an aspect hint as a richer alternative to a [tag](#common.tags):
while a tag conveys only a boolean state (the tag is either present or absent in the
`tags` list), an aspect hint can convey arbitrary structured information in its
[providers](/extending/rules#providers).

In practice, aspect hints are used for interoperability between different language-specific
rule sets. For example, imagine you have a `mylang_binary` target which needs to depend
on an `otherlang_library` target. The MyLang-specific logic needs some additional
information about the OtherLang target in order to use it, but `otherlang_library`
doesn't provide this information because it knows nothing about MyLang. One solution might be for
the MyLang rule set to define a `mylang_hint` rule which can be used to encode that
additional information; the user can add the hint to their `otherlang_library`'s
`aspect_hints`, and `mylang_binary` can use an aspect to collect the
additional information from a MyLang-specific provider in the `mylang_hint`.

For a concrete example, see
[`swift_interop_hint`](https://github.com/bazelbuild/rules_swift/blob/master/doc/rules.md#swift_interop_hint)
and [`swift_overlay`](https://github.com/bazelbuild/rules_swift/blob/master/doc/rules.md#swift_overlay)
in `rules_swift`.

Best practices:

- Targets listed in `aspect_hints` should be lightweight and minimal.
- Language-specific logic should consider only aspect hints having providers relevant to that
   language, and should ignore any other aspect hints.

`compatible_with`

List of [labels](/concepts/labels);
[nonconfigurable](#configurable-attributes); default is `[]`

The list of environments this target can be built for, in addition to
default-supported environments.

This is part of Bazel's constraint system, which lets users declare which
targets can and cannot depend on each other. For example, externally deployable
binaries shouldn't depend on libraries with company-secret code. See
[ConstraintSemantics](https://github.com/bazelbuild/bazel/blob/master/src/main/java/com/google/devtools/build/lib/analysis/constraints/ConstraintSemantics.java#L46) for details.

`deprecation`

String; [nonconfigurable](#configurable-attributes); default is `None`

An explanatory warning message associated with this target.
Typically this is used to notify users that a target has become obsolete,
or has become superseded by another rule, is private to a package, or is
perhaps considered harmful for some reason. It is a good idea to include
some reference (like a webpage, a bug number or example migration CLs) so
that one can easily find out what changes are required to avoid the message.
If there is a new target that can be used as a drop in replacement, it is a
good idea to just migrate all users of the old target.

This attribute has no effect on the way things are built, but it
may affect a build tool's diagnostic output. The build tool issues a
warning when a rule with a `deprecation` attribute is
depended upon by a target in another package.

Intra-package dependencies are exempt from this warning, so that,
for example, building the tests of a deprecated rule does not
encounter a warning.

If a deprecated target depends on another deprecated target, no warning
message is issued.

Once people have stopped using it, the target can be removed.

`exec_compatible_with`

List of [labels](/concepts/labels);
[nonconfigurable](#configurable-attributes); default is `[]`

A list of
`constraint_values`
that must be present in the execution platform of this target's default exec
group. This is in addition to any constraints already set by the rule type.
Constraints are used to restrict the list of available execution platforms.

For more details, see
the description of
[toolchain resolution](/docs/toolchains#toolchain-resolution).
and
[exec groups](/extending/exec-groups)

`exec_group_compatible_with`

Dictionary of strings to lists of [labels](/concepts/labels);
[nonconfigurable](#configurable-attributes); default is `{}`

A dictionary of exec group names to lists of
`constraint_values`
that must be present in the execution platform for the given exec group. This
is in addition to any constraints already set on the exec group's definition.
Constraints are used to restrict the list of available execution platforms.

For more details, see
the description of
[toolchain resolution](/docs/toolchains#toolchain-resolution).
and
[exec groups](/extending/exec-groups)

`exec_properties`

Dictionary of strings; default is `{}`

A dictionary of strings that will be added to the `exec_properties` of a platform selected for this target. See `exec_properties` of the [platform](platforms-and-toolchains.html#platform) rule.

If a key is present in both the platform and target-level properties, the value will be taken from the target.

Keys can be prefixed with the name of an execution group followed by a `.` to apply them only to that particular exec group.

`features`

List of _feature_ strings; default is `[]`

A feature is string tag that can be enabled or disabled on a target. The
meaning of a feature depends on the rule itself.

This `features` attribute is combined with the [package](/reference/be/functions.html#package) level `features` attribute. For example, if
the features \["a", "b"\] are enabled on the package level, and a target's
`features` attribute contains \["-a", "c"\], the features enabled for the
rule will be "b" and "c".
[See example](https://github.com/bazelbuild/examples/blob/main/rules/features/BUILD).

`package_metadata`

List of [labels](/concepts/labels);
[nonconfigurable](#configurable-attributes); default is the package's
`default_package_metadata`

A list of labels that are associated metadata about this target.
Typically, the labels are simple rules that return a provider of
constant values. Rules and aspects may use these labels to perform some
additional analysis on the build graph.

The canonical use case is that of
[rules\_license](https://github.com/bazelbuild/rules_license).
For that use case, `package_metadata` and
`default_package_metadata` is used to attach information
about a package's licence or version to targets. An aspect applied
to a top-level binary can be used to gather those and produce
compliance reports.

`restricted_to`

List of [labels](/concepts/labels);
[nonconfigurable](#configurable-attributes); default is `[]`

The list of environments this target can be built for, _instead_ of
default-supported environments.

This is part of Bazel's constraint system. See
`compatible_with`
for details.

`tags`

List of strings; [nonconfigurable](#configurable-attributes);
default is `[]`

_Tags_ can be used on any rule. _Tags_ on test and
`test_suite` rules are useful for categorizing the tests.
_Tags_ on non-test targets are used to control sandboxed execution of
`genrule` s and

[Starlark](/rules/concepts)
actions, and for parsing by humans and/or external tools.

Bazel modifies the behavior of its sandboxing code if it finds the following
keywords in the `tags` attribute of any test or `genrule`
target, or the keys of `execution_requirements` for any Starlark
action.

- `no-sandbox` keyword results in the action or test never being
   sandboxed; it can still be cached or run remotely - use `no-cache`
   or `no-remote` to prevent either or both of those.

- `no-cache` keyword results in the action or test never being
   cached (locally or remotely). Note: for the purposes of this tag, the disk cache
   is considered a local cache, whereas the HTTP and gRPC caches are considered
   remote. Other caches, such as Skyframe or the persistent action cache, are not
   affected.

- `no-remote-cache` keyword results in the action or test never being
   cached remotely (but it may be cached locally; it may also be executed remotely).
   Note: for the purposes of this tag, the disk cache is considered a local cache,
   whereas the HTTP and gRPC caches are considered remote. Other caches, such as
   Skyframe or the persistent action cache, are not affected.
   If a combination of local disk cache and remote cache are used (combined cache),
   it's treated as a remote cache and disabled entirely unless `--incompatible_remote_results_ignore_disk`
   is set in which case the local components will be used.

- `no-remote-exec` keyword results in the action or test never being
   executed remotely (but it may be cached remotely).

- `no-remote` keyword prevents the action or test from being executed remotely or
   cached remotely. This is equivalent to using both
   `no-remote-cache` and `no-remote-exec`.

- `no-remote-cache-upload` keyword disables upload part of remote caching of a spawn.
   it does not disable remote execution.

- `local` keyword precludes the action or test from being remotely cached,
   remotely executed, or run inside the sandbox.
   For genrules and tests, marking the rule with the `local = True`
   attribute has the same effect.

- `requires-network` keyword allows access to the external
   network from inside the sandbox. This tag only has an effect if sandboxing
   is enabled.

- `block-network` keyword blocks access to the external
   network from inside the sandbox. In this case, only communication
   with localhost is allowed. This tag only has an effect if sandboxing is
   enabled.

- `requires-fakeroot` runs the test or action as uid and gid 0 (i.e., the root
   user). This is only supported on Linux. This tag takes precedence over the
   `--sandbox_fake_username` command-line option.


_Tags_ on tests are generally used to annotate a test's role in your
debug and release process. Typically, tags are most useful for C++ and Python
tests, which lack any runtime annotation ability. The use of tags and size
elements gives flexibility in assembling suites of tests based around codebase
check-in policy.

Bazel modifies test running behavior if it finds the following keywords in the
`tags` attribute of the test rule:

- `exclusive` will force the test to be run in the
   "exclusive" mode, ensuring that no other tests are running at the
   same time. Such tests will be executed in serial fashion after all build
   activity and non-exclusive tests have been completed. Remote execution is
   disabled for such tests because Bazel doesn't have control over what's
   running on a remote machine.

- `exclusive-if-local` will force the test to be run in the
   "exclusive" mode if it is executed locally, but will run the test in parallel if it's
   executed remotely.

- `manual` keyword will exclude the target from expansion of target pattern wildcards
   ( `...`, `:*`, `:all`, etc.) and `test_suite` rules
   which do not list the test explicitly when computing the set of top-level targets to build/run
   for the `build`, `test`, and `coverage` commands. It does not
   affect target wildcard or test suite expansion in other contexts, including the
   `query` command. Note that `manual` does not imply that a target should
   not be built/run automatically by continuous build/test systems. For example, it may be
   desirable to exclude a target from `bazel test ...` because it requires specific
   Bazel flags, but still have it included in properly-configured presubmit or continuous test
   runs.


- `external` keyword will force test to be unconditionally
   executed (regardless of `--cache_test_results`
   value).


See
[Tag Conventions](/reference/test-encyclopedia#tag-conventions)
 in the Test Encyclopedia for more conventions on tags attached to test targets.
`target_compatible_with`

List of [labels](/concepts/labels); default is `[]`

A list of
`constraint_value` s
that must be present in the target platform for this target to be considered
_compatible_. This is in addition to any constraints already set by the
rule type. If the target platform does not satisfy all listed constraints then
the target is considered _incompatible_. Incompatible targets are
skipped for building and testing when the target pattern is expanded
(e.g. `//...`, `:all`). When explicitly specified on the
command line, incompatible targets cause Bazel to print an error and cause a
build or test failure.

Targets that transitively depend on incompatible targets are themselves
considered incompatible. They are also skipped for building and testing.

An empty list (which is the default) signifies that the target is compatible
with all platforms.

All rules other than [Workspace Rules](workspace.html) support this
attribute.
For some rules this attribute has no effect. For example, specifying
`target_compatible_with` for a
`cc_toolchain` is not useful.

See the
[Platforms](/docs/platforms#skipping-incompatible-targets)
page for more information about incompatible target skipping.

`testonly`

Boolean; [nonconfigurable](#configurable-attributes); default is `False`
except for test and test suite targets

If `True`, only testonly targets (such as tests) can depend on this target.

Equivalently, a rule that is not `testonly` is not allowed to
depend on any rule that is `testonly`.

Tests ( `*_test` rules)
and test suites ( [test\_suite](/reference/be/general.html#test_suite) rules)
are `testonly` by default.

This attribute is intended to mean that the target should not be
contained in binaries that are released to production.

Because testonly is enforced at build time, not run time, and propagates
virally through the dependency tree, it should be applied judiciously. For
example, stubs and fakes that
are useful for unit tests may also be useful for integration tests
involving the same binaries that will be released to production, and
therefore should probably not be marked testonly. Conversely, rules that
are dangerous to even link in, perhaps because they unconditionally
override normal behavior, should definitely be marked testonly.

`toolchains`

List of [labels](/concepts/labels);
[nonconfigurable](#configurable-attributes); default is `[]`

The set of targets whose [Make variables](/reference/be/make-variables) this target is
allowed to access. These targets are either instances of rules that provide
`TemplateVariableInfo` or special targets for toolchain types built into Bazel. These
include:

- `@bazel_tools//tools/cpp:toolchain_type`
- `@rules_java//toolchains:current_java_runtime`

Note that this is distinct from the concept of
[toolchain resolution](/docs/toolchains#toolchain-resolution)
that is used by rule implementations for platform-dependent configuration. You cannot use this
attribute to determine which specific `cc_toolchain` or `java_toolchain` a
target will use.

`visibility`

List of [labels](/concepts/labels);
[nonconfigurable](#configurable-attributes);
default varies

The `visibility` attribute controls whether the target can be
depended on by targets in other locations. See the documentation for
[visibility](/concepts/visibility).

For targets declared directly in a BUILD file or in legacy macros called from
a BUILD file, the default value is the package's
`default_visibility`
if specified, or else `["//visibility:private"]`. For targets
declared in one or more symbolic macros, the default value is always just
`["//visibility:private"]` (which makes it useable only within the
package containing the macro's code).

## Attributes common to all test rules (\*\_test)

This section describes attributes that are common to all test rules.

AttributeDescription`args`

List of strings; subject to
[$(location)](/reference/be/make-variables#predefined_label_variables) and
["Make variable"](/reference/be/make-variables) substitution, and
[Bourne shell tokenization](#sh-tokenization); default is `[]`

Command line arguments that Bazel passes to the target when it is
executed with `bazel test`.

These arguments are passed before any `--test_arg` values
specified on the `bazel test` command line.

`env`

Dictionary of strings; values are subject to
[$(location)](/reference/be/make-variables#predefined_label_variables) and
["Make variable"](/reference/be/make-variables) substitution; default is `{}`

Specifies additional environment variables to set when the test is executed by
`bazel test`.

This attribute only applies to native rules, like `cc_test`,
`py_test`, and `sh_test`. It does not apply to
Starlark-defined test rules. For your own Starlark rules, you can add an "env"
attribute and use it to populate a

[RunEnvironmentInfo](/rules/lib/providers/RunEnvironmentInfo.html)
Provider.

[TestEnvironment](/rules/lib/toplevel/testing#TestEnvironment)

 Provider.

`env_inherit`

List of strings; default is `[]`

Specifies additional environment variables to inherit from the
external environment when the test is executed by `bazel test`.

This attribute only applies to native rules, like `cc_test`, `py_test`,
and `sh_test`. It does not apply to Starlark-defined test rules.

`size`

String `"enormous"`, `"large"`, `"medium"`, or
`"small"`; [nonconfigurable](#configurable-attributes);
default is `"medium"`

Specifies a test target's "heaviness": how much time/resources it needs to run.

Unit tests are considered "small", integration tests "medium", and end-to-end tests "large" or
"enormous". Bazel uses the size to determine a default timeout, which can be overridden using the
`timeout` attribute. The timeout is for all tests in the BUILD target, not for each
individual test. When the test is run locally, the `size` is additionally used for
scheduling purposes: Bazel tries to respect `--local_{ram,cpu}_resources` and not
overwhelm the local machine by running lots of heavy tests at the same time.

Test sizes correspond to the following default timeouts and assumed peak local resource
usages:

SizeRAM (in MB)CPU (in CPU cores)Default timeoutsmall201short (1 minute)medium1001moderate (5 minutes)large3001long (15 minutes)enormous8001eternal (60 minutes)

The environment variable
`TEST_SIZE` will be set to
the value of this attribute when spawning the test.

`timeout`

String `"short"`, `"moderate"`, `"long"`, or
`"eternal"`; [nonconfigurable](#configurable-attributes); default is derived
from the test's `size` attribute

How long the test is expected to run before returning.

While a test's size attribute controls resource estimation, a test's
timeout may be set independently. If not explicitly specified, the
timeout is based on the [test's size](#test.size). The test
timeout can be overridden with the `--test_timeout` flag, e.g. for
running under certain conditions which are known to be slow. Test timeout values
correspond to the following time periods:

Timeout ValueTime Periodshort1 minutemoderate5 minuteslong15 minuteseternal60 minutes

For times other than the above, the test timeout can be overridden with the
`--test_timeout` bazel flag, e.g. for manually running under
conditions which are known to be slow. The `--test_timeout` values
are in seconds. For example `--test_timeout=120` will set the test
timeout to two minutes.

The environment variable
`TEST_TIMEOUT` will be set
to the test timeout (in seconds) when spawning the test.

`flaky`

Boolean; [nonconfigurable](#configurable-attributes);
default is `False`

Marks test as flaky.

If set, executes the test up to three times, marking it as failed only if it
fails each time. By default, this attribute is set to False and the test is
executed only once. Note, that use of this attribute is generally discouraged -
tests should pass reliably when their assertions are upheld.

`shard_count`

Non-negative integer less than or equal to 50; default is `-1`

Specifies the number of parallel shards
to use to run the test.

If set, this value will override any heuristics used to determine the number of
parallel shards with which to run the test. Note that for some test
rules, this parameter may be required to enable sharding
in the first place. Also see `--test_sharding_strategy`.

If test sharding is enabled, the environment variable `
TEST_TOTAL_SHARDS
` will be set to this value when spawning the test.

Sharding requires the test runner to support the test sharding protocol.
If it does not, then it will most likely run every test in every shard, which
is not what you want.

See
[Test Sharding](/reference/test-encyclopedia#test-sharding)
in the Test Encyclopedia for details on sharding.

`local`

Boolean; [nonconfigurable](#configurable-attributes);
default is `False`

Forces the test to be run locally, without sandboxing.

Setting this to True is equivalent to providing "local" as a tag
( `tags=["local"]`).

## Attributes common to all binary rules (\*\_binary)

This section describes attributes that are common to all binary rules.

AttributeDescription`args`

List of strings; subject to
[$(location)](/reference/be/make-variables#predefined_label_variables) and
["Make variable"](/reference/be/make-variables) substitution, and
[Bourne shell tokenization](#sh-tokenization);
[nonconfigurable](#configurable-attributes);
default is `[]`

Command line arguments that Bazel will pass to the target when it is executed
either by the `run` command or as a test. These arguments are
passed before the ones that are specified on the `bazel run` or
`bazel test` command line.

_NOTE: The arguments are not passed when you run the target_
_outside of Bazel (for example, by manually executing the binary in_
_`bazel-bin/`)._

`env`

Dictionary of strings; values are subject to
[$(location)](/reference/be/make-variables#predefined_label_variables) and
["Make variable"](/reference/be/make-variables) substitution; default is `{}`

Specifies additional environment variables to set when the target is
executed by `bazel run`.

This attribute only applies to native rules, like `cc_binary`, `py_binary`,
and `sh_binary`. It does not apply to Starlark-defined executable rules. For your own
Starlark rules, you can add an "env" attribute and use it to populate a

[RunEnvironmentInfo](/rules/lib/providers/RunEnvironmentInfo.html)

Provider.

_NOTE: The environment variables are not set when you run the target_
_outside of Bazel (for example, by manually executing the binary in_
_`bazel-bin/`)._

`output_licenses`

List of strings; default is `[]`

The licenses of the output files that this binary generates.

This is part of a deprecated licensing API that Bazel no longer uses. Don't
use this.

## Configurable attributes

Most attributes are "configurable", meaning that their values may change when
the target is built in different ways. Specifically, configurable attributes
may vary based on the flags passed to the Bazel command line, or what
downstream dependency is requesting the target. This can be used, for
instance, to customize the target for multiple platforms or compilation modes.

The following example declares different sources for different target
architectures. Running `bazel build :multiplatform_lib --cpu x86`
will build the target using `x86_impl.cc`, while substituting
`--cpu arm` will instead cause it to use `arm_impl.cc`.

```
cc_library(
    name = "multiplatform_lib",
    srcs = select({
        ":x86_mode": ["x86_impl.cc"],
        ":arm_mode": ["arm_impl.cc"]
    })
)
config_setting(
    name = "x86_mode",
    values = { "cpu": "x86" }
)
config_setting(
    name = "arm_mode",
    values = { "cpu": "arm" }
)

```

The [`select()`](/reference/be/functions.html#select) function
chooses among different alternative values for a configurable attribute based
on which [`config_setting`](/reference/be/general.html#config_setting)
or [`constraint_value`](/reference/be/platforms-and-toolchains.html#constraint_value)
criteria the target's configuration satisfies.

Bazel evaluates configurable attributes after processing macros and before
processing rules (technically, between the
[loading and analysis phases](https://bazel.build/rules/concepts#evaluation-model)).
Any processing before `select()` evaluation doesn't know which
branch the `select()` chooses. Macros, for example, can't change
their behavior based on the chosen branch, and `bazel query` can
only make conservative guesses about a target's configurable dependencies. See
[this FAQ](https://bazel.build/docs/configurable-attributes#faq)
for more on using `select()` with rules and macros.

Attributes marked `nonconfigurable` in their documentation cannot
use this feature. Usually an attribute is nonconfigurable because Bazel
internally needs to know its value before it can determine how to resolve a
`select()`.

See [Configurable Build Attributes](https://bazel.build/docs/configurable-attributes) for a detailed overview.

## Implicit output targets

_Implicit outputs in C++ are deprecated. Please refrain from using it_
_in other languages where possible. We don't have a deprecation path yet_
_but they will eventually be deprecated too._

When you define a build rule in a BUILD file, you are explicitly
declaring a new, named rule target in a package. Many build rule
functions also _implicitly_ entail one or more output file
targets, whose contents and meaning are rule-specific.

For example, when you explicitly declare a
`java_binary(name='foo', ...)` rule, you are also
_implicitly_ declaring an output file
target `foo_deploy.jar` as a member of the same package.
(This particular target is a self-contained Java archive suitable
for deployment.)

Implicit output targets are first-class members of the global
target graph. Just like other targets, they are built on demand,
either when specified in the top-level built command, or when they
are necessary prerequisites for other build targets. They can be
referenced as dependencies in BUILD files, and can be observed in
the output of analysis tools such as `bazel query`.

For each kind of build rule, the rule's documentation contains a
special section detailing the names and contents of any implicit
outputs entailed by a declaration of that kind of rule.

An important but somewhat subtle distinction between the
two namespaces used by the build system:
[labels](/concepts/labels) identify _targets_,
which may be rules or files, and file targets may be divided into
either source (or input) file targets and derived (or output) file
targets. These are the things you can mention in BUILD files,
build from the command-line, or examine using `bazel query`;
this is the _target namespace_. Each file target corresponds
to one actual file on disk (the "file system namespace"); each rule
target may correspond to zero, one or more actual files on disk.
There may be files on disk that have no corresponding target; for
example, `.o` object files produced during C++ compilation
cannot be referenced from within BUILD files or from the command line.
In this way, the build tool may hide certain implementation details of
how it does its job. This is explained more fully in
the [BUILD Concept Reference](/concepts/build-ref).

### Make Variables
- URL: https://bazel.build/reference/be/make-variables
- Source: reference/be/make-variables.mdx

- [Use](#use)
- [Predefined variables](#predefined_variables)
- [Predefined genrule variables](#predefined_genrule_variables)
- [Predefined source/output path variables](#predefined_label_variables)
- [Custom variables](#custom_variables)

"Make" variables are a special class of expandable string variables available
to attributes marked as _"Subject to 'Make variable' substitution"_.

These can be used, for example, to inject specific toolchain paths into
user-constructed build actions.

Bazel provides both _predefined_ variables, which are available to all
targets, and _custom_ variables, which are defined in dependency targets
and only available to targets that depend on them.

The reason for the term "Make" is historical: the syntax and semantics of
these variables were originally intended to match [GNU\
Make](https://www.gnu.org/software/make/manual/html_node/Using-Variables.html).

## Use

Attributes marked as _"Subject to 'Make variable' substitution"_ can
reference the "Make" variable `FOO` as follows:

`my_attr = "prefix $(FOO) suffix"`

In other words, any substring matching `$(FOO)` gets expanded
to `FOO`'s value. If that value is `"bar"`, the final
string becomes:

`my_attr = "prefix bar suffix"`

If `FOO` doesn't correspond to a variable known to the consuming
target, Bazel fails with an error.

"Make" variables whose names are non-letter symbols, such as
`@`, can also be referenced using only a dollar sign, without
the parentheses. For example:

`my_attr = "prefix $@ suffix"`

To write `$` as a string literal (i.e. to prevent variable
expansion), write `$$`.

## Predefined variables

Predefined "Make" variables can be referenced by any attribute marked as
_"Subject to 'Make variable' substitution"_ on any target.

To see the list of these variables and their values for a given set of build
options, run

`bazel info --show_make_env [build options]`

and look at the top output lines with capital letters.

[See an example of predefined variables](https://github.com/bazelbuild/examples/tree/main/make-variables#predefined-variables).

**Toolchain option variables**

- `COMPILATION_MODE`:
   `fastbuild`, `dbg`, or `opt`. ( [more\
   details](https://bazel.build/docs/user-manual#flag--compilation_mode))


**Path variables**

- `BINDIR`: The base of the generated binary tree for the target
   architecture.



   Note that a different tree may be used for programs that run during the
   build on the host architecture, to support cross-compiling.



   If you want to run a tool from within a `genrule`, the
   recommended way to get its path is `$(execpath toolname)`,
   where _toolname_ must be listed in the `genrule`'s
   `tools` attribute.


- `GENDIR`:
   The base of the generated code tree for the target architecture.


**Machine architecture variables**

- `TARGET_CPU`:
   The target architecture's CPU, e.g. `k8`.

## Predefined genrule variables

The following are specially available to `genrule`'s
`cmd` attribute and are
generally important for making that attribute work.

[See an example of predefined genrule variables](https://github.com/bazelbuild/examples/tree/main/make-variables#predefined-genrule-variables).

- `OUTS`: The `genrule`'s `outs` list. If you have
   only one output file, you can also use `$@`.
- `SRCS`: The `genrule`'s `srcs` list (or more
   precisely: the path names of the files corresponding to labels in the
   `srcs` list).
   If you have only one source file, you can also use `$<`.

- `<`: `SRCS`, if it is a single file. Else triggers
   a build error.

- `@`: `OUTS`, if it is a single file. Else triggers a
   build error.

- `RULEDIR`: The output directory of the target, that is, the
   directory corresponding to the name of the package containing the target
   under the `genfiles` or `bin` tree. For
   `//my/pkg:my_genrule` this always ends in `my/pkg`,
   even if `//my/pkg:my_genrule`'s outputs are in subdirectories.


- `@D`: The output directory. If
   [outs](/reference/be/general.html#genrule.outs) has one entry,
   this expands to the directory containing that file. If it has multiple
   entries, this expands to the package's root directory in the
   `genfiles` tree, _even if all output files are in the same_
  _subdirectory_!


  **Note:** Use `RULEDIR` over `@D` because
   `RULEDIR` has simpler semantics and behaves the same way
   regardless of the number of output files.



   If the genrule needs to generate temporary intermediate files (perhaps as
   a result of using some other tool like a compiler), it should attempt to
   write them to `@D` (although `/tmp` will also
   be writable) and remove them before finishing.



   Especially avoid writing to directories containing inputs. They may be on
   read-only filesystems. Even if not, doing so would trash the source tree.



**Note:** If the filenames corresponding to the input labels or the output
filenames contain spaces, `'`, or other special characters (or your
genrule is part of a Starlark macro which downstream users may invoke on such
files), then `$(SRCS)` and `$(OUTS)` are not suitable
for interpolation into a command line, as they do not have the semantics that
`"${@}"` would in Bash.

One workaround is to convert to a Bash array, with


```
mapfile SRCS <<< "$$(sed -e 's/ /\\n/g' <<'genrule_srcs_expansion'
$(SRC)
genrule_srcs_expansion
)
```

and then use `"$$\{SRCS[@]}"` in subsequent command lines in place
of `$(SRCS)`. A more robust option is to write a Starlark rule
instead.

## Predefined source/output path variables

The predefined variables `execpath`, `execpaths`,
`rootpath`, `rootpaths`, `location`, and
`locations` take label parameters (e.g. `$(execpath
//foo:bar)`) and substitute the file paths denoted by that label.

For source files, this is the path relative to your workspace root.
For files that are outputs of rules, this is the file's _output path_
(see the explanation of _output files_ below).

[See an example of predefined path variables](https://github.com/bazelbuild/examples/tree/main/make-variables#predefined-path-variables).

- `execpath`: Denotes the path beneath the

   [execroot](/docs/output_directories)
   where Bazel runs build actions.



   In the above example, Bazel runs all build actions in the directory linked
   by the `bazel-myproject` symlink in your workspace root. The
   source file `empty.source` is linked at the path
   `bazel-myproject/testapp/empty.source`. So its exec path (which
   is the subpath below the root) is `testapp/empty.source`. This
   is the path build actions can use to find the file.



   Output files are staged similarly, but are also prefixed with the subpath
   `bazel-out/cpu-compilation_mode/bin` (or for the outputs of
   tools: `bazel-out/cpu-opt-exec-hash/bin`). In the above example,
   `//testapp:app` is a tool because it appears in
   `show_app_output`'s `tools` attribute.
   So its output file `app` is written to
   `bazel-myproject/bazel-out/cpu-opt-exec-hash/bin/testapp/app`.
   The exec path is thus `
        bazel-out/cpu-opt-exec-hash/bin/testapp/app`. This extra prefix
   makes it possible to build the same target for, say, two different CPUs in
   the same build without the results clobbering each other.



   The label passed to this variable must represent exactly one file. For
   labels representing source files, this is automatically true. For labels
   representing rules, the rule must generate exactly one output. If this is
   false or the label is malformed, the build fails with an error.


- `rootpath`: Denotes the path that a built binary can use to
   find a dependency at runtime relative to the subdirectory of its runfiles
   directory corresponding to the main repository.
   **Note:** This only works if [`--enable_runfiles`](/reference/command-line-reference#flag--enable_runfiles) is enabled, which is not the case on
   Windows by default. Use `rlocationpath` instead for
   cross-platform support.



   This is similar to `execpath` but strips the configuration
   prefixes described above. In the example from above this means both
   `empty.source` and `app` use pure workspace-relative
   paths: `testapp/empty.source` and `testapp/app`.



   The `rootpath` of a file in an external repository
   `repo` will start with `../repo/`, followed by the
   repository-relative path.



   This has the same "one output only" requirements as `execpath`.


- `rlocationpath`: The path a built binary can pass to the `
        Rlocation` function of a runfiles library to find a dependency at
   runtime, either in the runfiles directory (if available) or using the
   runfiles manifest.



   This is similar to `rootpath` in that it does not contain
   configuration prefixes, but differs in that it always starts with the
   name of the repository. In the example from above this means that `
        empty.source` and `app` result in the following
   paths: `myproject/testapp/empty.source` and `
        myproject/testapp/app`.



   The `rlocationpath` of a file in an external repository
   `repo` will start with `repo/`, followed by the
   repository-relative path.



   Passing this path to a binary and resolving it to a file system path using
   the runfiles libraries is the preferred approach to find dependencies at
   runtime. Compared to `rootpath`, it has the advantage that it
   works on all platforms and even if the runfiles directory is not
   available.



   This has the same "one output only" requirements as `execpath`.


- `location`: A synonym for either `execpath` or
   `rootpath`, depending on the attribute being expanded. This is
   legacy pre-Starlark behavior and not recommended unless you really know what
   it does for a particular rule. See [#2475](https://github.com/bazelbuild/bazel/issues/2475#issuecomment-339318016)
   for details.


`execpaths`, `rootpaths`, `rlocationpaths`,
and `locations` are the plural variations of `execpath`,
`rootpath`, `rlocationpath`, and `location`,
respectively. They support labels producing multiple outputs, in which case
each output is listed separated by a space. Zero-output rules and malformed
labels produce build errors.

All referenced labels must appear in the consuming target's `srcs`,
output files, or `deps`. Otherwise the build fails. C++ targets can
also reference labels in `data`.

Labels don't have to be in canonical form: `foo`, `:foo`
and `//somepkg:foo` are all fine.

## Custom variables

Custom "Make" variables can be referenced by any attribute marked as
_"Subject to 'Make variable' substitution"_, but only on targets that
depend on other targets that _define_ these variables.

As best practice all variables should be custom unless there's a really good
reason to bake them into core Bazel. This saves Bazel from having to load
potentially expensive dependencies to supply variables consuming tarets may
not care about.

**C++ toolchain variables**

The following are defined in C++ toolchain rules and available to any rule
that sets `toolchains =
["@bazel_tools//tools/cpp:toolchain_type"]`
Some rules, like `java_binary`, implicitly
include the C++ toolchain in their rule definition. They inherit these variables
automatically.

The built-in C++ rules are much more sophisticated than "run the compiler on
it". In order to support compilation modes as diverse as \*SAN, ThinLTO,
with/without modules, and carefully optimized binaries at the same time as
fast running tests on multiple platforms, the built-in rules go to great
lengths to ensure the correct inputs, outputs, and command-line flags are set
on each of potentially multiple internally generated actions.

These variables are a fallback mechanism to be used by language experts in
rare cases. If you are tempted to use them, please [contact the Bazel devs](https://bazel.build/help) first.

- `ABI`: The C++ ABI version.
- `AR`: The "ar" command from crosstool.
- `C_COMPILER`:
   The C/C++ compiler identifier, e.g. `llvm`.

- `CC`: The C and C++ compiler command.


   We strongly recommended always using `CC_FLAGS` in
   combination with `CC`. Fail to do so at your own risk.


- `CC_FLAGS`: A minimal set of flags for the C/C++
   compiler to be usable by genrules. In particular, this contains flags to
   select the correct architecture if `CC` supports multiple
   architectures.

- `DUMPBIN`: Microsoft COFF Binary File Dumper (dumpbin.exe) from
   from Microsoft Visual Studio.
- `NM`: The "nm" command from crosstool.
- `OBJCOPY`: The objcopy command from the same suite as the C/C++
   compiler.
- `STRIP`: The strip command from the same suite as the C/C++
   compiler.

**Java toolchain variables**

The following are defined in Java toolchain rules and available to any rule
that sets `toolchains =
["@rules_java//toolchains:current_java_runtime"]` (or
`"@rules_java//toolchains:current_host_java_runtime"`
for the host toolchain equivalent).

Most of the tools in the JDK should not be used directly. The built-in Java
rules use much more sophisticated approaches to Java compilation and packaging
than upstream tools can express, such as interface Jars, header interface
Jars, and highly optimized Jar packaging and merging implementations.

These variables are a fallback mechanism to be used by language experts in
rare cases. If you are tempted to use them, please [contact the Bazel devs](https://bazel.build/help) first.

- `JAVA`: The "java" command (a Java virtual
   machine). Avoid this, and use a `java_binary` rule
   instead where possible. May be a relative path. If you must change
   directories before invoking `java`, you need to capture the
   working directory before changing it.

- `JAVABASE`: The base directory containing the
   Java utilities. May be a relative path. It will have a "bin"
   subdirectory.


**Starlark-defined variables**

Rule and [toolchain](/docs/toolchains) writers can define
completely custom variables by returning a
[TemplateVariableInfo](/rules/lib/TemplateVariableInfo)
provider. Any rules depending on these through the
`toolchains` attribute can then read their values:

[See an example of Starlark-defined variables](https://github.com/bazelbuild/examples/tree/main/make-variables#custom-starlark-defined-variables).


## Glossary

### Bazel Glossary
- URL: https://bazel.build/reference/glossary
- Source: reference/glossary.mdx

### Action

A command to run during the build, for example, a call to a compiler that takes
[artifacts](#artifact) as inputs and produces other artifacts as outputs.
Includes metadata like the command line arguments, action key, environment
variables, and declared input/output artifacts.

**See also:** [Rules documentation](/extending/rules#actions)

### Action cache

An on-disk cache that stores a mapping of executed [actions](#action) to the
outputs they created. The cache key is known as the [action key](#action-key). A
core component for Bazel's incrementality model. The cache is stored in the
output base directory and thus survives Bazel server restarts.

### Action graph

An in-memory graph of [actions](#action) and the [artifacts](#artifact) that
these actions read and generate. The graph might include artifacts that exist as
source files (for example, in the file system) as well as generated
intermediate/final artifacts that are not mentioned in `BUILD` files. Produced
during the [analysis phase](#analysis-phase) and used during the [execution
phase](#execution-phase).

### Action graph query (aquery)

A [query](#query-concept) tool that can query over build [actions](#action).
This provides the ability to analyze how [build rules](#rule) translate into the
actual work builds do.

### Action key

The cache key of an [action](#action). Computed based on action metadata, which
might include the command to be executed in the action, compiler flags, library
locations, or system headers, depending on the action. Enables Bazel to cache or
invalidate individual actions deterministically.

### Analysis phase

The second phase of a build. Processes the [target graph](#target-graph)
specified in [`BUILD` files](#build-file) to produce an in-memory [action
graph](#action-graph) that determines the order of actions to run during the
[execution phase](#execution-phase). This is the phase in which rule
implementations are evaluated.

### Artifact

A source file or a generated file. Can also be a directory of files, known as
[tree artifacts](#tree-artifact).

An artifact may be an input to multiple actions, but must only be generated by
at most one action.

An artifact that corresponds to a [file target](#target) can be addressed by a
label.

### Aspect

A mechanism for rules to create additional [actions](#action) in their
dependencies. For example, if target A depends on B, one can apply an aspect on
A that traverses *up* a dependency edge to B, and runs additional actions in B
to generate and collect additional output files. These additional actions are
cached and reused between targets requiring the same aspect. Created with the
`aspect()` Starlark Build API function. Can be used, for example, to generate
metadata for IDEs, and create actions for linting.

**See also:** [Aspects documentation](/extending/aspects)

### Aspect-on-aspect

A composition mechanism whereby aspects can be applied to the results
of other aspects. For example, an aspect that generates information for use by
IDEs can be applied on top of an aspect that generates `.java` files from a
proto.

For an aspect `A` to apply on top of aspect `B`, the [providers](#provider) that
`B` advertises in its [`provides`](/rules/lib/globals#aspect.provides) attribute
must match what `A` declares it wants in its [`required_aspect_providers`](/rules/lib/globals#aspect.required_aspect_providers)
attribute.

### Attribute

A parameter to a [rule](#rule), used to express per-target build information.
Examples include `srcs`, `deps`, and `copts`, which respectively declare a
target's source files, dependencies, and custom compiler options. The particular
attributes available for a given target depend on its rule type.

### .bazelrc

Bazels configuration file used to change the default values for [startup
flags](#startup-flags) and [command flags](#command-flags), and to define common
groups of options that can then be set together on the Bazel command line using
a `--config` flag. Bazel can combine settings from multiple bazelrc files
(systemwide, per-workspace, per-user, or from a custom location), and a
`bazelrc` file may also import settings from other `bazelrc` files.

### Blaze

The Google-internal version of Bazel. Googles main build system for its
mono-repository.

### BUILD File

A `BUILD` file is the main configuration file that tells Bazel what software
outputs to build, what their dependencies are, and how to build them. Bazel
takes a `BUILD` file as input and uses the file to create a graph of dependencies
and to derive the actions that must be completed to build intermediate and final
software outputs. A `BUILD` file marks a directory and any sub-directories not
containing a `BUILD` file as a [package](#package), and can contain
[targets](#target) created by [rules](#rule). The file can also be named
`BUILD.bazel`.

### BUILD.bazel File

See [`BUILD` File](#build-file). Takes precedence over a `BUILD` file in the same
directory.

### .bzl File

A file that defines rules, [macros](#macro), and constants written in
[Starlark](#starlark). These can then be imported into [`BUILD`
files](#build-file) using the `load()` function.

{/* TODO: ### Build event protocol */}

{/* TODO: ### Build flag */}

### Build graph

The dependency graph that Bazel constructs and traverses to perform a build.
Includes nodes like [targets](#target), [configured
targets](#configured-target), [actions](#action), and [artifacts](#artifact). A
build is considered complete when all [artifacts](#artifact) on which a set of
requested targets depend are verified as up-to-date.

### Build setting

A Starlark-defined piece of [configuration](#configuration).
[Transitions](#transition) can set build settings to change a subgraph's
configuration. If exposed to the user as a [command-line flag](#command-flags),
also known as a build flag.

### Clean build

A build that doesn't use the results of earlier builds. This is generally slower
than an [incremental build](#incremental-build) but commonly considered to be
more [correct](#correctness). Bazel guarantees both clean and incremental builds
are always correct.

### Client-server model

The `bazel` command-line client automatically starts a background server on the
local machine to execute Bazel [commands](#command). The server persists across
commands but automatically stops after a period of inactivity (or explicitly via
bazel shutdown). Splitting Bazel into a server and client helps amortize JVM
startup time and supports faster [incremental builds](#incremental-build)
because the [action graph](#action-graph) remains in memory across commands.

### Command

Used on the command line to invoke different Bazel functions, like `bazel
build`, `bazel test`, `bazel run`, and `bazel query`.

### Command flags

A set of flags specific to a [command](#command). Command flags are specified
*after* the command (`bazel build <command flags>`). Flags can be applicable to
one or more commands. For example, `--configure` is a flag exclusively for the
`bazel sync` command, but `--keep_going` is applicable to `sync`, `build`,
`test` and more. Flags are often used for [configuration](#configuration)
purposes, so changes in flag values can cause Bazel to invalidate in-memory
graphs and restart the [analysis phase](#analysis-phase).

### Configuration

Information outside of [rule](#rule) definitions that impacts how rules generate
[actions](#action). Every build has at least one configuration specifying the
target platform, action environment variables, and command-line [build
flags](#command-flags). [Transitions](#transition) may create additional
configurations, such as for host tools or cross-compilation.

**See also:** [Configurations](/extending/rules#configurations)

{/* TODO: ### Configuration fragment */}

### Configuration trimming

The process of only including the pieces of [configuration](#configuration) a
target actually needs. For example, if you build Java binary `//:j` with C++
dependency `//:c`, it's wasteful to include the value of `--javacopt` in the
configuration of `//:c` because changing `--javacopt` unnecessarily breaks C++
build cacheability.

### Configured query (cquery)

A [query](#query-concept) tool that queries over [configured
targets](#configured-target) (after the [analysis phase](#analysis-phase)
completes). This means `select()` and [build flags](#command-flags) (such as
`--platforms`) are accurately reflected in the results.

**See also:** [cquery documentation](/query/cquery)

### Configured target

The result of evaluating a [target](#target) with a
[configuration](#configuration). The [analysis phase](#analysis-phase) produces
this by combining the build's options with the targets that need to be built.
For example, if `//:foo` builds for two different architectures in the same
build, it has two configured targets: `<//:foo, x86>` and `<//:foo, arm>`.

### Correctness

A build is correct when its output faithfully reflects the state of its
transitive inputs. To achieve correct builds, Bazel strives to be
[hermetic](#hermeticity), reproducible, and making [build
analysis](#analysis-phase) and [action execution](#execution-phase)
deterministic.

### Dependency

A directed edge between two [targets](#target). A target `//:foo` has a *target
dependency* on target `//:bar` if `//:foo`'s attribute values contain a
reference to `//:bar`. `//:foo` has an *action dependency* on `//:bar` if an
action in `//:foo` depends on an input [artifact](#artifact) created by an
action in `//:bar`.

In certain contexts, it could also refer to an _external dependency_; see
[modules](#module).

### Depset

A data structure for collecting data on transitive dependencies. Optimized so
that merging depsets is time and space efficient, because its common to have
very large depsets (hundreds of thousands of files). Implemented to
recursively refer to other depsets for space efficiency reasons. [Rule](#rule)
implementations should not "flatten" depsets by converting them to lists unless
the rule is at the top level of the build graph. Flattening large depsets incurs
huge memory consumption. Also known as *nested sets* in Bazel's internal
implementation.

**See also:** [Depset documentation](/extending/depsets)

### Disk cache

A local on-disk blob store for the remote caching feature. Can be used in
conjunction with an actual remote blob store.

### Distdir

A read-only directory containing files that Bazel would otherwise fetch from the
internet using repository rules. Enables builds to run fully offline.

### Dynamic execution

An execution strategy that selects between local and remote execution based on
various heuristics, and uses the execution results of the faster successful
method. Certain [actions](#action) are executed faster locally (for example,
linking) and others are faster remotely (for example, highly parallelizable
compilation). A dynamic execution strategy can provide the best possible
incremental and clean build times.

### Execution phase

The third phase of a build. Executes the [actions](#action) in the [action
graph](#action-graph) created during the [analysis phase](#analysis-phase).
These actions invoke executables (compilers, scripts) to read and write
[artifacts](#artifact). *Spawn strategies* control how these actions are
executed: locally, remotely, dynamically, sandboxed, docker, and so on.

### Execution root

A directory in the [workspace](#workspace)s [output base](#output-base)
directory where local [actions](#action) are executed in
non-[sandboxed](#sandboxing) builds. The directory contents are mostly symlinks
of input [artifacts](#artifact) from the workspace. The execution root also
contains symlinks to external repositories as other inputs and the `bazel-out`
directory to store outputs. Prepared during the [loading phase](#loading-phase)
by creating a *symlink forest* of the directories that represent the transitive
closure of packages on which a build depends. Accessible with `bazel info
execution_root` on the command line.

### File

See [Artifact](#artifact).

### Hermeticity

A build is hermetic if there are no external influences on its build and test
operations, which helps to make sure that results are deterministic and
[correct](#correctness). For example, hermetic builds typically disallow network
access to actions, restrict access to declared inputs, use fixed timestamps and
timezones, restrict access to environment variables, and use fixed seeds for
random number generators

### Incremental build

An incremental build reuses the results of earlier builds to reduce build time
and resource usage. Dependency checking and caching aim to produce correct
results for this type of build. An incremental build is the opposite of a clean
build.

{/* TODO: ### Install base */}

### Label

An identifier for a [target](#target). Generally has the form
`@repo//path/to/package:target`, where `repo` is the (apparent) name of the
[repository](#repository) containing the target, `path/to/package` is the path
to the directory that contains the [`BUILD` file](#build-file) declaring the
target (this directory is also known as the [package](#package)), and `target`
is the name of the target itself. Depending on the situation, parts of this
syntax may be omitted.

**See also**: [Labels](/concepts/labels)

### Loading phase

The first phase of a build where Bazel executes [`BUILD` files](#build-file) to
create [packages](#package). [Macros](#macro) and certain functions like
`glob()` are evaluated in this phase. Interleaved with the second phase of the
build, the [analysis phase](#analysis-phase), to build up a [target
graph](#target-graph).

### Legacy macro

A flavor of [macro](#macro) which is declared as an ordinary
[Starlark](#starlark) function, and which runs as a side effect of executing a
`BUILD` file.

Legacy macros can do anything a function can. This means they can be convenient,
but they can also be harder to read, write, and use. A legacy macro might
unexpectedly mutate its arguments or fail when given a `select()` or ill-typed
argument.

Contrast with [symbolic macros](#symbolic-macro).

**See also:** [Legacy macro documentation](/extending/legacy-macros)

### Macro

A mechanism to compose multiple [rule](#rule) target declarations together under
a single [Starlark](#starlark) callable. Enables reusing common rule declaration
patterns across `BUILD` files. Expanded to the underlying rule target
declarations during the [loading phase](#loading-phase).

Comes in two flavors: [symbolic macros](#symbolic-macro) (since Bazel 8) and
[legacy macros](#legacy-macro).

### Mnemonic

A short, human-readable string selected by a rule author to quickly understand
what an [action](#action) in the rule is doing. Mnemonics can be used as
identifiers for *spawn strategy* selections. Some examples of action mnemonics
are `Javac` from Java rules, `CppCompile` from C++ rules, and
`AndroidManifestMerger` from Android rules.

### Module

A Bazel project that can have multiple versions, each of which can have
dependencies on other modules. This is analogous to familiar concepts in other
dependency management systems, such as a Maven _artifact_, an npm _package_, a
Go _module_, or a Cargo _crate_. Modules form the backbone of Bazel's external
dependency management system.

Each module is backed by a [repo](#repository) with a `MODULE.bazel` file at its
root. This file contains metadata about the module itself (such as its name and
version), its direct dependencies, and various other data including toolchain
registrations and [module extension](#module-extension) input.

Module metadata is hosted in Bazel registries.

**See also:** [Bazel modules](/external/module)

### Module Extension

A piece of logic that can be run to generate [repos](#repository) by reading
inputs from across the [module](#module) dependency graph and invoking [repo
rules](#repository-rule). Module extensions have capabilities similar to repo
rules, allowing them to access the internet, perform file I/O, and so on.

**See also:** [Module extensions](/external/extension)

### Native rules

[Rules](#rule) that are built into Bazel and implemented in Java. Such rules
appear in [`.bzl` files](#bzl-file) as functions in the native module (for
example, `native.cc_library` or `native.java_library`). User-defined rules
(non-native) are created using [Starlark](#starlark).

### Output base

A [workspace](#workspace)-specific directory to store Bazel output files. Used
to separate outputs from the *workspace*'s source tree (the [main
repo](#repository)). Located in the [output user root](#output-user-root).

### Output groups

A group of files that is expected to be built when Bazel finishes building a
target. [Rules](#rule) put their usual outputs in the "default output group"
(e.g the `.jar` file of a `java_library`, `.a` and `.so` for `cc_library`
targets). The default output group is the output group whose
[artifacts](#artifact) are built when a target is requested on the command line.
Rules can define more named output groups that can be explicitly specified in
[`BUILD` files](#build-file) (`filegroup` rule) or the command line
(`--output_groups` flag).

### Output user root

A user-specific directory to store Bazel's outputs. The directory name is
derived from the user's system username. Prevents output file collisions if
multiple users are building the same project on the system at the same time.
Contains subdirectories corresponding to build outputs of individual workspaces,
also known as [output bases](#output-base).

### Package

The set of [targets](#target) defined by a [`BUILD` file](#build-file). A
package's name is the `BUILD` file's path relative to the [repo](#repository)
root. A package can contain subpackages, or subdirectories containing `BUILD`
files, thus forming a package hierarchy.

### Package group

A [target](#target) representing a set of packages. Often used in `visibility`
attribute values.

### Platform

A "machine type" involved in a build. This includes the machine Bazel runs on
(the "host" platform), the machines build tools execute on ("exec" platforms),
and the machines targets are built for ("target platforms").

### Provider

A schema describing a unit of information to pass between
[rule targets](#rule-target) along dependency relationships. Typically this
contains information like compiler options, transitive source or output files,
and build metadata. Frequently used in conjunction with [depsets](#depset) to
efficiently store accumulated transitive data. An example of a built-in provider
is `DefaultInfo`.

Note: The object holding specific data for a given rule target is
referred to as a "provider instance", although sometimes this is conflated with
"provider".

**See also:** [Provider documentation](/extending/rules#providers)

### Query (concept)

The process of analyzing a [build graph](#build-graph) to understand
[target](#target) properties and dependency structures. Bazel supports three
query variants: [query](#query-command), [cquery](#configured-query), and
[aquery](#action-graph-query).

### query (command)

A [query](#query-concept) tool that operates over the build's post-[loading
phase](#loading-phase) [target graph](#target-graph). This is relatively fast,
but can't analyze the effects of `select()`, [build flags](#command-flags),
[artifacts](#artifact), or build [actions](#action).

**See also:** [Query how-to](/query/guide), [Query reference](/query/language)

### Repository

A directory tree with a boundary marker file at its root, containing source
files that can be used in a Bazel build. Often shortened to just **repo**.

A repo boundary marker file can be `MODULE.bazel` (signaling that this repo
represents a Bazel module), `REPO.bazel`, or in legacy contexts, `WORKSPACE` or
`WORKSPACE.bazel`. Any repo boundary marker file will signify the boundary of a
repo; multiple such files can coexist in a directory.

The *main repo* is the repo in which the current Bazel command is being run.

*External repos* are defined by specifying [modules](#module) in `MODULE.bazel`
files, or invoking [repo rules](#repository-rule) in [module
extensions](#module-extension). They can be fetched on demand to a predetermined
"magical" location on disk.

Each repo has a unique, constant *canonical* name, and potentially different
*apparent* names when viewed from other repos.

**See also**: [External dependencies overview](/external/overview)

### Repository cache

A shared content-addressable cache of files downloaded by Bazel for builds,
shareable across [workspaces](#workspace). Enables offline builds after the
initial download. Commonly used to cache files downloaded through [repository
rules](#repository-rule) like `http_archive` and repository rule APIs like
`repository_ctx.download`. Files are cached only if their SHA-256 checksums are
specified for the download.

### Repository rule

A schema for repository definitions that tells Bazel how to materialize (or
"fetch") a [repository](#repository). Often shortened to just **repo rule**.
Repo rules are invoked by Bazel internally to define repos backed by
[modules](#module), or can be invoked by [module extensions](#module-extension).
Repo rules can access the internet or perform file I/O; the most common repo
rule is `http_archive` to download an archive containing source files from the
internet.

**See also:** [Repo rule documentation](/external/repo)

### Reproducibility

The property of a build or test that a set of inputs to the build or test will
always produce the same set of outputs every time, regardless of time, method,
or environment. Note that this does not necessarily imply that the outputs are
[correct](#correctness) or the desired outputs.

### Rule

A schema for defining [rule targets](#rule-target) in a `BUILD` file, such as
`cc_library`. From the perspective of a `BUILD` file author, a rule consists of
a set of [attributes](#attributes) and black box logic. The logic tells the
rule target how to produce output [artifacts](#artifact) and pass information to
other rule targets. From the perspective of `.bzl` authors, rules are the
primary way to extend Bazel to support new programming languages and
environments.

Rules are instantiated to produce rule targets in the
[loading phase](#loading-phase). In the [analysis phase](#analysis-phase) rule
targets communicate information to their downstream dependencies in the form of
[providers](#provider), and register [actions](#action) describing how to
generate their output artifacts. These actions are run in the [execution
phase](#execution-phase).

Note: Historically the term "rule" has been used to refer to a rule target.
This usage was inherited from tools like Make, but causes confusion and should
be avoided for Bazel.

**See also:** [Rules documentation](/extending/rules)

### Rule target

A [target](#target) that is an instance of a rule. Contrasts with file targets
and package groups. Not to be confused with [rule](#rule).

### Runfiles

The runtime dependencies of an executable [target](#target). Most commonly, the
executable is the executable output of a test rule, and the runfiles are runtime
data dependencies of the test. Before the invocation of the executable (during
bazel test), Bazel prepares the tree of runfiles alongside the test executable
according to their source directory structure.

**See also:** [Runfiles documentation](/extending/rules#runfiles)

### Sandboxing

A technique to isolate a running [action](#action) inside a restricted and
temporary [execution root](#execution-root), helping to ensure that it doesnt
read undeclared inputs or write undeclared outputs. Sandboxing greatly improves
[hermeticity](#hermeticity), but usually has a performance cost, and requires
support from the operating system. The performance cost depends on the platform.
On Linux, it's not significant, but on macOS it can make sandboxing unusable.

### Skyframe

[Skyframe](/reference/skyframe) is the core parallel, functional, and incremental evaluation framework of Bazel.

{/* TODO: ### Spawn strategy */}

### Stamping

A feature to embed additional information into Bazel-built
[artifacts](#artifact). For example, this can be used for source control, build
time and other workspace or environment-related information for release builds.
Enable through the `--workspace_status_command` flag and [rules](/extending/rules) that
support the stamp attribute.

### Starlark

The extension language for writing [rules](/extending/rules) and [macros](#macro). A
restricted subset of Python (syntactically and grammatically) aimed for the
purpose of configuration, and for better performance. Uses the [`.bzl`
file](#bzl-file) extension. [`BUILD` files](#build-file) use an even more
restricted version of Starlark (such as no `def` function definitions), formerly
known as Skylark.

**See also:** [Starlark language documentation](/rules/language)

{/* TODO: ### Starlark rules */}

{/* TODO: ### Starlark rule sandwich */}

### Startup flags

The set of flags specified between `bazel` and the [command](#query-command),
for example, bazel `--host_jvm_debug` build. These flags modify the
[configuration](#configuration) of the Bazel server, so any modification to
startup flags causes a server restart. Startup flags are not specific to any
command.

### Symbolic macro

A flavor of [macro](#macro) which is declared with a [rule](#rule)-like
[attribute](#attribute) schema, allows hiding internal declared
[targets](#target) from their own package, and enforces a predictable naming
pattern on the targets that the macro declares. Designed to avoid some of the
problems seen in large [legacy macro](#legacy-macro) codebases.

**See also:** [Symbolic macro documentation](/extending/macros)

### Target

An object that is defined in a [`BUILD` file](#build-file) and identified by a
[label](#label). Targets represent the buildable units of a workspace from
the perspective of the end user.

A target that is declared by instantiating a [rule](#rule) is called a [rule
target](#rule-target). Depending on the rule, these may be runnable (like
`cc_binary`) or testable (like `cc_test`). Rule targets typically depend on
other targets via their [attributes](#attribute) (such as `deps`); these
dependencies form the basis of the [target graph](#target-graph).

Aside from rule targets, there are also file targets and [package group](#package-group)
targets. File targets correspond to [artifacts](#artifact) that are referenced
within a `BUILD` file. As a special case, the `BUILD` file of any package is
always considered a source file target in that package.

Targets are discovered during the [loading phase](#loading-phase). During the
[analysis phase](#analysis-phase), targets are associated with [build
configurations](#configuration) to form [configured
targets](#configured-target).

### Target graph

An in-memory graph of [targets](#target) and their dependencies. Produced during
the [loading phase](#loading-phase) and used as an input to the [analysis
phase](#analysis-phase).

### Target pattern

A way to specify a group of [targets](#target) on the command line. Commonly
used patterns are `:all` (all rule targets), `:*` (all rule + file targets),
`...` (current [package](#package) and all subpackages recursively). Can be used
in combination, for example, `//...:*` means all rule and file targets in all
packages recursively from the root of the [workspace](#workspace).

### Tests

Rule [targets](#target) instantiated from test rules, and therefore contains a
test executable. A return code of zero from the completion of the executable
indicates test success. The exact contract between Bazel and tests (such as test
environment variables, test result collection methods) is specified in the [Test
Encyclopedia](/reference/test-encyclopedia).

### Toolchain

A set of tools to build outputs for a language. Typically, a toolchain includes
compilers, linkers, interpreters or/and linters. A toolchain can also vary by
platform, that is, a Unix compiler toolchain's components may differ for the
Windows variant, even though the toolchain is for the same language. Selecting
the right toolchain for the platform is known as toolchain resolution.

### Top-level target

A build [target](#target) is top-level if its requested on the Bazel command
line. For example, if `//:foo` depends on `//:bar`, and `bazel build //:foo` is
called, then for this build, `//:foo` is top-level, and `//:bar` isnt
top-level, although both targets will need to be built. An important difference
between top-level and non-top-level targets is that [command
flags](#command-flags) set on the Bazel command line (or via
[.bazelrc](#bazelrc)) will set the [configuration](#configuration) for top-level
targets, but might be modified by a [transition](#transition) for non-top-level
targets.

### Transition

A mapping of [configuration](#configuration) state from one value to another.
Enables [targets](#target) in the [build graph](#build-graph) to have different
configurations, even if they were instantiated from the same [rule](#rule). A
common usage of transitions is with *split* transitions, where certain parts of
the [target graph](#target-graph) is forked with distinct configurations for
each fork. For example, one can build an Android APK with native binaries
compiled for ARM and x86 using split transitions in a single build.

**See also:** [User-defined transitions](/extending/config#user-defined-transitions)

### Tree artifact

An [artifact](#artifact) that represents a collection of files. Since these
files are not themselves artifacts, an [action](#action) operating on them must
instead register the tree artifact as its input or output.

### Visibility

One of two mechanisms for preventing unwanted dependencies in the build system:
*target visibility* for controlling whether a [target](#target) can be depended
upon by other targets; and *load visibility* for controlling whether a `BUILD`
or `.bzl` file may load a given `.bzl` file. Without context, usually
"visibility" refers to target visibility.

**See also:** [Visibility documentation](/concepts/visibility)

### Workspace

The environment shared by all Bazel commands run from the same [main
repository](#repository).

Note that historically the concepts of "repository" and "workspace" have been
conflated; the term "workspace" has often been used to refer to the main
repository, and sometimes even used as a synonym of "repository". Such usage
should be avoided for clarity.
